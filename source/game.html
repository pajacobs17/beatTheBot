<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>Welcome</title>
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
	<link rel="stylesheet" href="css/style.css">
	<script src = "engine/simpleGame_1_0.js"></script>

	<!--SCRIPTS -->
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
	
	<!-- priority queue script -->
	<script src="https://unpkg.com/tinyqueue@2.0.0/tinyqueue.min.js"></script>
	
	<!-- class files -->
	<script src="Enemy.js"></script>
	<script src="Player.js"></script>
	<script src="Node.js"></script>
	<script src="priority-queue.js"></script>
	<script src="Queue.js"></script>
	<!--<script src="PriorityQueue.js"></script> -->
	
</head>

<body onload="init()" style="background-color: #003366;">

	<script>
		var queue = new Queue();
		//determines the number of enemies on the board
		var ENEMIES = 4;
		//timer refers to the miliseonds for the set-up timer, is in the setUpPhase function
		var TIMER = 5000;
		//NxN dimensions of the matrix, also determines number of walls that player gets (3X currently)
		var SQUARES = 10;
		//number of fish to be picked up, will be randomly placed
		var FISH = 4;
		
		//setting up the canvas that the game will be played on
        var game;
		
		//list of enemies for pathing in game
		var enemyList = [];
		
		//var for player sprite
		var player;
		
		//var for fish list (item to be picked up for win condition)
		var fishList = [];
		
		//board Sprite
		var board;
		
		//canvas variables allow for accessing height and width throughout program
		var canvas;
		
		//initializes various elements, including the mower and gnome sprites
		//creates the initial board of grass sprites, starts the game
        function init() {
			
			game = new Scene();
			//get the canvas elements for the game to allow for dynamic resizing
			var all = document.getElementsByTagName("canvas");
			canvas = all[0];
			
			canvas.addEventListener("click", onClick, false);
			
			//settting background
			game.setBG("#ADD8E6");
			
			board = new Array();
			
			createBoard();
			
			for(var i = 0; i < ENEMIES; i++) {
				enemyList.push(new Enemy(game, "../images/Enemy.png", canvas.clientWidth/SQUARES, canvas.clientHeight/SQUARES));
				
				randIndex = randNode();
				randRow = randIndex[0];
				randCol = randIndex[1];
				
				x = board[randRow][randCol].x;
				y = board[randRow][randCol].y;
				
				enemyList[i].setPosition(x, y);
			}

			player = new Player(game, "../images/Player.png", canvas.clientWidth/SQUARES - 10, canvas.clientHeight/SQUARES - 10, SQUARES * 3);
			player.setPosition(canvas.clientWidth - canvas.clientWidth/SQUARES, canvas.clientHeight - canvas.clientHeight/SQUARES);
			
			//create all the fish objects
			for(var i = 0; i < FISH; i++) {
				fishList[i] = new Sprite(game, "../images/fish.jpg", canvas.clientWidth/SQUARES, canvas.clientHeight/SQUARES);
				var pos = randNode();
				//makes the fishes location the same as a square (or node) on the board
				console.log(pos[0] + ", " + pos[1]);
				fishList[i].x = board[pos[0]][pos[1]].x;
				fishList[i].y = board[pos[0]][pos[1]].y;
			}
			
			createGraph();
			
			setupPhase();
			
            game.start();		
        }
		
		
		//function to handle when the canvas is clicked, e is the click event
		function onClick(e) {
			var x = event.x - canvas.offsetLeft;
			var y = event.y - canvas.offsetTop;
			//if the player has walls remainign
			if(player.walls > 0) {
				//if a wall was placed, remove a wall from the player's inventory
				if(nodeClicked(x, y) == true) {
					player.walls -= 1;
				}
			}
		}
		
		 /* function should return a location within bounds of canvas */
        function randNode(){
          //generate random number for a random row index of the board
			var randRow = Math.floor(Math.random() * (board.length - 0));
			//same but for column
			var randCol = Math.floor(Math.random() * (board[0].length - 0));
			
			if(board[randRow][randCol].isWall == true) {
				randNode();
			}
		  
          return [randRow, randCol];
        }
		
		//create the board 2d array with all the node elements inside it
		function createBoard() {
			//keep track of the current row and colummn, used to create the 2d array
			var rowIndex = 0;
			var columnIndex = 0;
			
			//proper board piece square and height since the canvas is dynamic
			var squareHeight = canvas.clientHeight/SQUARES;
			var squareWidth = canvas.clientWidth/SQUARES;
			
			//i starts with an offset of half an image height since the engine places images based on their center
			//assumes all images in the board will be the same size as the 0 element
			for(var i = squareHeight/2; i <= canvas.clientHeight; i += squareHeight) {
				//adds the inner array at the current row column index
				board[columnIndex] = new Array();
				//adds the node at the given row and column
				for(var j = squareWidth/2; j <= canvas.clientWidth; j += squareWidth) {
					board[columnIndex][rowIndex] = new Node(game, "../images/Square.jpg", squareWidth, squareHeight);
					board[columnIndex][rowIndex].setPosition(j, i);
					rowIndex++;	
				}
			//reset row index for the next inner loop iteration
			rowIndex = 0;
			//increment the column index
			columnIndex++;
			}
		}	
		
		function drawTempSprite(x, y) {
			//i will create a sprite at the location of the click and test it against each node to detect collision
			var tempSprite = new Sprite(game, "../images/collision.jpg", 1, 1);
			//set position to the location clicked and draw it
			tempSprite.setPosition(x, y);
			tempSprite.update();
			
			return tempSprite;
		}
		
		
		function nodeClicked(x, y) {	
			//i will create a sprite at the location of the click and test it against each node to detect collision
			var tempSprite = drawTempSprite(x, y);
		
			if(tempSprite.collidesWith(player)) {
				player.setSpeed(0);
				return false;
			}
		
			//same for enemies
			for(var i = 0; i < enemyList.length; i++) {
				if(tempSprite.collidesWith(enemyList[i])) {
					return false;
				}
			}
			

			//go through all the nodes, change the image of the node clicked
			for(var i = 0; i < board.length; i++) {
				for(var j = 0; j < board[i].length; j++) {
					if(board[i][j].collidesWith(tempSprite) && board[i][j].isWall == false) {
						board[i][j].makeWall();
						//change the cost to infinity so AI will never move towards it
						return true;
					}
				}
			}
			return false;
		}
		
        //is called for every "frame", clears the frame then displays the current state
        function update() {
			//erase previous frame
			game.clear();
			
			//goes through all the nodes seeing if the player has hit any that are walls
			//if the player has, set hitWall to true and that will be handled
			for(var i = 0; i < board.length; i++) {
				for(var j = 0; j < board[i].length; j++) {
					if(board[i][j].collidesWith(player) && board[i][j].isWall == true) {
						//if/else for handling when a player runs into wall, currently not working
						//***********************************
					}
					board[i][j].update();
				}
			}
			player.checkKeys();

			//hides the fish if the player has picked it up
			for(var i = 0; i < fishList.length; i++) {
				if(player.collidesWith(fishList[i])) {
					fishList[i].hide();
				}
				fishList[i].update();
			}
			
			//after checking collisions for each fish, check if the win condition is fulfilled			
			checkWin();
			
			
			//iterates through each enemy in the enemyList
			for(var i = 0; i < enemyList.length; i++) {
				//tempSprite1 will be used to see if the player is in the node
				//tempSprite2 will be used to see if the enemy is in the node
				//create them using the current x and y of the player and the current enemy
				var tempSprite1 = drawTempSprite(player.x, player.y);
				var tempSprite2 = drawTempSprite(enemyList[i].x, enemyList[i].y);
				
				var start;
				var goal;
				
				for(var j = 0; j < board.length; j++) {
					for(var k = 0; k < board[j].length; k++) {
						//performance could be improved by removing this from the enemyList for loop potentially
						//not necessarily worth it
						if(board[j][k].collidesWith(tempSprite1)) {
							goal = board[j][k];
						}
						if(board[j][k].collidesWith(tempSprite2)) {
							start = board[j][k];
						}
					}
				}

				//calculates the nextMove for the enemy
				enemyList[i].nextMove(start, goal);
				//check for a loss and then draw the enemy
				checkLoss(enemyList[i]);
				enemyList[i].draw();	
			}
			player.draw();	
        }
		
		function setupPhase() {
			var countTo = new Date().getTime() + TIMER;
			
			var sec = setInterval(function() {
				var now = new Date().getTime();
				
				var timeLeft = countTo - now;
				
				var seconds = Math.floor((timeLeft % (1000 * 60))/1000);
				//**************************** output to html element **********************
				console.log(seconds)
				
				if(timeLeft <= 0) {
					clearInterval(sec);
				}
			}, 1000);
		}

		 /*
          check whether or not the player has colllided with a Gnome
          if the player has collided with a Gnome, end the game with an alert and beyond
          refreshing the page
        */
        function checkLoss(enemy) {
          //if a collision has occured, end the game
            if (player.collidesWith(enemy)){
                alert("You have lost");
                game.stop();
            }
        }
		
		function checkWin() {
			for(var i = 0; i < fishList.length; i++) {
				//if any of the fish are visible, i.e. not picked up, end the function
				if(fishList[i].visible == true) {
					return;
				}
			}
			//tell the user they have won and stop the game
			alert("You have won");
			
			game.stop();
		}
		
		function createGraph() {
			for(var i = 0; i < board.length; i++) {
				for(var j = 0; j < board[i].length; j++) {
					//adding neighbors to each node of the graph, checking bounds to make sure
					//all are within the array
					var n1, n2, n3, n4;
					if(i > 0) {
						n1 = board[i - 1][j];
						board[i][j].neighbors.push(n1);
					}
					//board.length -1 to get the last index, it's a square board matrix so using i or j won't matter for
					//checking if the arrays is in bounds
					if(i < board.length - 1) {
						n2 = board[i+1][j];
						board[i][j].neighbors.push(n2);
					}
					if(j > 0) {
						n3 = board[i][j - 1];
						board[i][j].neighbors.push(n3);
					}
					if(j < board.length - 1) {
						n4 = board[i][j + 1];
						board[i][j].neighbors.push(n4);
					}
				}
			}
		}
		
	</script>
</body>

</html>
