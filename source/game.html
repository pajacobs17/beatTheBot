<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>Welcome</title>
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
	<script src = "engine/simpleGame_1_0.js"></script>

	<!--SCRIPTS -->
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
	
	<!-- priority queue script -->
	<script src="https://unpkg.com/tinyqueue@2.0.0/tinyqueue.min.js"></script>
	
	<!-- class files -->
	<script src="Enemy.js"></script>
	<script src="Player.js"></script>
	<script src="Node.js"></script>
	<!--<script src="PriorityQueue.js"></script> -->
	
</head>

<body onload="init()" style="background-color: #003366;">

	<script>
		//determines the number of enemies on the board
		var ENEMIES = 1;
		//timer refers to the miliseonds for the set-up timer, is in the setUpPhase function
		var TIMER = 5000;
		//number of squares, canvas height will be divided by italic
		var SQUARES = 5;
		//number of fish to be picked up, will be randomly placed
		var FISH = 3;
		
		//setting up the canvas that the game will be played on
        var game;
		
		//list of enemies for pathing in game
		var enemyList = [];
		
		//var for player sprite
		var player;
		
		//var for fish list (item to be picked up for win condition)
		var fishList = [];
		
		//board Sprite
		var board;
		
		//canvas variables allow for accessing height and width throughout program
		var canvas;
		

		//initializes various elements, including the mower and gnome sprites
		//creates the initial board of grass sprites, starts the game
        function init() {
			game = new Scene();
			//get the canvas elements for the game to allow for dynamic resizing
			var all = document.getElementsByTagName("canvas");
			canvas = all[0];
			
			canvas.addEventListener("click", onClick, false);
			
			//settting background
			game.setBG("#ADD8E6");
			
			console.log(randPos());
			
			for(var i = 0; i < ENEMIES; i++) {
				enemyList.push(new Enemy(game, "../images/Enemy.png", canvas.clientWidth/SQUARES, canvas.clientHeight/SQUARES, SQUARES * 2));
				//enemyList[i].setPosition(400, 400);
			}			
			board = new Array();
			//priority is cost from node to neighbor, value is current minimum cost to a node
			
			enemyList[0].setPosition(canvas.clientHeight/SQUARES, canvas.clientHeight/SQUARES);
			var pos = [(canvas.clientHeight - canvas.clientHeight/SQUARES), (canvas.clientWidth - canvas.clientWidth/SQUARES)];
			//enemyList[1].setPosition(pos[0], pos[1]);
			//enemyList[2].setPosition(400, 400);
			//enemyList[3].setPosition(100, 400);
			
			player = new Player(game, "../images/Player.png", canvas.clientWidth/SQUARES, canvas.clientHeight/SQUARES, SQUARES);
			player.setPosition(canvas.clientWidth - canvas.clientWidth/SQUARES, canvas.clientHeight - canvas.clientHeight/SQUARES);
			
			createBoard();
			
			for(var i = 0; i < FISH; i++) {
				fishList[i] = new Sprite(game, "../images/fish.jpg", canvas.clientWidth/SQUARES, canvas.clientHeight/SQUARES);
				var pos = randPos();
				fishList[i].x = pos[0];
				fishList[i].y = pos[1];
			}
			
			setupPhase();
			
            game.start();
			
        }
		
		
		//function to handle when the canvas is clicked, e is the click event
		function onClick(e) {
			var x = event.x - canvas.offsetLeft;
			var y = event.y - canvas.offsetTop;
			//if the player has walls remainign
			if(player.walls > 0) {
				//if a wall was placed, remove a wall from the player's inventory
				if(nodeClicked(x, y) == true) {
					player.walls -= 1;
				}
			}
		}
		
		 /* function should return a location within bounds of canvas */
        function randPos(){
          //setting max and min to make fish will be within bounds of canvas
          var heightMax = canvas.clientHeight - canvas.clientHeight/SQUARES;
		  var heightMin = canvas.clientHeight/SQUARES;
		  
		  //same for width
		  var widthMax = canvas.clientWidth - canvas.clientWidth/SQUARES;
          var widthMin = canvas.clientHeight/SQUARES;
		  
		  
          var randX = Math.floor(Math.random() * (widthMax - widthMin)) + widthMin;
		  var randY = Math.floor(Math.random() * (heightMax - heightMin)) + widthMin;
		  
          return [randX, randY];
        }
		
		//create the board 2d array with all the node elements inside it
		function createBoard() {
			//keep track of the current row and colummn, used to create the 2d array
			var rowIndex = 0;
			var columnIndex = 0;
			
			//proper board piece square and height since the canvas is dynamic
			var squareHeight = canvas.clientHeight/SQUARES;
			var squareWidth = canvas.clientWidth/SQUARES;
			
			//i starts with an offset of half an image height since the engine places images based on their center
			//assumes all images in the board will be the same size as the 0 element
			for(var i = squareHeight/2; i <= canvas.clientHeight; i += squareHeight) {
				//adds the inner array at the current row column index
				board[columnIndex] = new Array();
				//adds the node at the given row and column
				for(var j = squareWidth/2; j <= canvas.clientWidth; j += squareWidth) {
					board[columnIndex][rowIndex] = new Node(game, "../images/Square.jpg", squareWidth, squareHeight);
					board[columnIndex][rowIndex].setPosition(j, i);
					rowIndex++;	
				}
			//reset row index for the next inner loop iteration
			rowIndex = 0;
			//increment the column index
			columnIndex++;
			}
		}	
		
		function nodeClicked(x, y) {	
			//i will create a sprite at the location of the click and test it against each node to detect collision
			var tempSprite = new Sprite(game, "../images/collision.jpg", 1, 1);
			//set position to the location clicked and draw it
			tempSprite.setPosition(x, y);
			tempSprite.update();
			
			if(tempSprite.collidesWith(player)) {
				return false;
			}
		
			
			//checks to make sure that walls can't be placed where sprite currently are
			for(var i = 0; i < enemyList.length; i++) {
				if(tempSprite.collidesWith(enemyList[i])) {
					return false;
				}
			}

			//go through all the nodes, change the image of the node clicked
			for(var i = 0; i < board.length; i++) {
				for(var j = 0; j < board[i].length; j++) {
					if(board[i][j].collidesWith(tempSprite) && board[i][j].isWall == false) {
						board[i][j].makeWall()
						return true;
					}
				}
			}
			return false;
		}
		
        //is called for every "frame", clears the frame then displays the current state
        function update() {
			var hitWall = false;
			
			game.clear();
			
			for(var i = 0; i < board.length; i++) {
				for(var j = 0; j < board[i].length; j++) {
					if(board[i][j].collidesWith(player) && board[i][j].isWall == true) {
						hitWall = true;
					}
					board[i][j].update();
				}
			}
			
			//hides the fish if the player has picked it up
			//*************************** program for win condition
			for(var i = 0; i < fishList.length; i++) {
				if(player.collidesWith(fishList[i])) {
					fishList[i].hide();
				}
				fishList[i].update();
			}
			//check for loss, when enemy sprite has hit player sprite
			for(var i = 0; i < enemyList.length; i++) {
				checkLoss(enemyList[i]);
				enemyList[i].draw();	
			}
			//if/else for handling when a player runs into wall, currently not working
			//***********************************
			if(hitWall == false) {
				player.setSpeed(5);
				player.checkKeys();
			}
			else {
				player.setSpeed(0);
			}
			player.draw();	
        }
		
		function setupPhase() {
			var countTo = new Date().getTime() + TIMER;
			
			var sec = setInterval(function() {
				var now = new Date().getTime();
				
				var timeLeft = countTo - now;
				
				var seconds = Math.floor((timeLeft % (1000 * 60))/1000);
				//**************************** output to html element **********************
				console.log(seconds)
				
				if(timeLeft <= 0) {
					clearInterval(sec);
				}
			}, 1000);
		}

		 /*
          check whether or not the player has colllided with a Gnome
          if the player has collided with a Gnome, end the game with an alert and beyond
          refreshing the page
        */
        function checkLoss(enemy) {
          //if a collision has occured, end the game
            if (player.collidesWith(enemy)){
                alert("You have lost");
                game.stop();
            }
        }
		
		function createGraph() {
			
		}
		
		function Dijstra(graph, source, destination) {
			//create vertex set Q
			var q = [];
			
			
		}

		
		
	</script>
</body>

</html>
